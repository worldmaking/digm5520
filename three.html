<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Three.js</title>
<meta name="description" content="">
<meta name="author" content="Graham Wakefield">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="css/basic.css" type="text/css" />
<link rel="stylesheet" href="css/github.css" type="text/css" />
<style>
td { 
	vertical-align: top;
}

img {
	max-height: 75vh;
}

header {
	background-color:#f5f5f5;
	font-size: 75%;
	padding: 0.5em;
}
footer {
	background-color:#f5f5f5;
	font-size: 75%;
	padding: 0.5em;
}
.responsive-google-slides {
    position: relative;
    padding-bottom: 60%; /* 16:9 Ratio = 56.25%, 4:3 ratio = 75% */
    height: 0;
    overflow: hidden;
}
.responsive-google-slides iframe {
	border: 0;
	position: absolute;
	top: 0;
	left: 0;
	width: 100% !important;
	height: 100% !important;
}
</style>
<script src="https://unpkg.com/@stackblitz/sdk/bundles/sdk.umd.js"></script>
</head>
<body class="centremaxwidth960">
<header><a href="index.html">DATT4520 & DIGM5520: Generative Art in Mixed Reality / Spatial Computing in Responsive Environments</a></header>
<ul>
<li><a href="#threejs">Three.js</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#starter-code">Starter code</a></li>
<li><a href="#webxr-starter-code">WebXR starter code</a></li>
<li><a href="#notes-on-stackblitz">Notes on Stackblitz</a></li>
<li><a href="#timing">Timing</a></li>
<li><a href="#navigation">Navigation</a></li>
<li><a href="#a-quick-gui">A quick GUI</a></li>
</ul>
</li>
</ul>

<hr>
<h1 id="threejs">Three.js</h1>
<p><a href="https://threejs.org/">Three.js</a> is probably the widest-used library for working with GPU-accelerated 3D graphics in the browser. </p>
<ul>
<li><a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">Documentation</a></li>
<li><a href="https://threejs.org/examples/">Amazing collection of examples</a></li>
<li><a href="https://threejsfundamentals.org/">More great tutorial material at https://threejsfundamentals.org/</a> -- if slightly out of date on some aspects</li>
</ul>
<h2 id="overview">Overview</h2>
<p>Three.js builds upon the <a href="https://github.com/worldmaking/worldmaking.github.io/wiki/WebGL-notes">WebGL</a> API available in recent browsers, which is built upon OpenGL, one of the oldest and most established 3D hardware graphics APIs. But whereas the WebGL (and OpenGL) APIs are relatively low-level and state-based, Three.js offers a more mid-level object-based interface, including a &quot;scene-graph&quot;, &quot;materials&quot;, and other elements you might find in a modern game engine. But on the other hand, unlike a game engine, we create a scene not through a drag &amp; drop user interface, but by typing code (as we might with Processing or P5.js etc.) The structure of a Three.js code document might look something like this:</p>
<ul>
<li>Setup code to create/generate/load/define resources their properties</li>
<li>An <code>animate()</code> function that defines the core animation loop, updating at 60fps (desktop) or higher (VR)</li>
<li>Other event handler functions to deal with interaction etc.</li>
</ul>
<p>At the heart of any Three.js project is an animation loop in which a <code>THREE.WebGLRenderer</code> takes a <code>THREE.Camera</code> and a <code>THREE.Scene</code> to actually draw to the screen. </p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// update members &amp; properties of the scene here for animation</span>
    <span class="hljs-comment">// TODO</span>

    <span class="hljs-comment">// now render the scene:</span>
    renderer.render(scene, camera);
}
renderer.setAnimationLoop(render);
</code></pre>
<p>Before this loop there will be setup code to define the <code>renderer</code>, the <code>camera</code>, but most of all, the actual contents of the <code>scene</code>. The <code>scene</code> is much like the scene graph of game engines: a tree-like structure in which each node contains child objects. </p>
<h3 id="ontology">Ontology</h3>
<p><img src="https://01.org/sites/default/files/resize/users/u71223/process-overview-530x275.png" alt="overview"></p>
<p>The <code>Three.js</code> ontology is roughly as follows:</p>
<ul>
<li><p>Renderer (<code>THREE.WebGLRenderer</code>)</p>
<ul>
<li>Mostly static settings for rendering options, e.g. <code>antialias: true</code></li>
</ul>
</li>
<li><p>Camera (<code>THREE.PerspectiveCamera</code>, <code>THREE.OrthographicCamera</code>, <code>THREE.StereoCamera</code>, etc.). For VR/XR we will always be using <code>THREE.PerspectiveCamera</code>.</p>
<ul>
<li>There could be many cameras, but only one is used to render per frame</li>
<li>Camera is also an Object3D</li>
</ul>
</li>
<li><p>Scene (<code>THREE.Scene</code>) -- root object of a scene graph tree</p>
<ul>
<li><p>There could be many scenes, but only one is used to render per frame</p>
</li>
<li><p>Every object in the tree inherits from the base class <a href="https://threejs.org/docs/index.html?q=object3#api/en/core/Object3D">THREE.Object3D</a></p>
<ul>
<li>Has a pose (position/orientation/scale), children, parent, visible, etc. properties</li>
<li>can be an empty container (but better to use <code>THREE.Group</code> for that)</li>
<li><code>.layers</code>: an object is only rendered if it has a layer tag in common with the camera. Also used to filter raycasting.</li>
<li>Static objects should set <code>object.matrixAutoUpdate  = false;</code></li>
</ul>
</li>
<li><p>Meshes (usually <code>THREE.Mesh</code>)</p>
<ul>
<li>Geometry (THREE has lots of built-in geometry constructors and loaders<ul>
<li>For procedural geometries use <code>THREE.BufferGeometry</code> (actually everything uses this under the hood). Geometry based on Javascript Typed Arrays -- more flexible, faster</li>
</ul>
</li>
<li>Material (THREE has lots of built-in material types from <code>MeshBasicMaterial</code> and <code>MeshStandardMaterial</code> to customized <code>ShaderMaterial</code>)<ul>
<li>Materials may use textures (&quot;maps&quot;) for some of their surface details. <ul>
<li>For dynamic textures, keep setting texture.needsUpdate = true;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>For many objects, use <a href="https://threejs.org/docs/index.html?q=instance#api/en/objects/InstancedMesh">THREE.InstancedMesh</a>, InstancedBufferAttribute, InstancedBufferGeometry, etc.</p>
</li>
<li><p>Lights (THREE has several light types to choose from, such as <code>HemisphereLight</code>, <code>AmbientLight</code>, <code>SpotLight</code>, <code>PointLight</code>, <code>DirectionalLight</code>, etc.</p>
</li>
<li><p>Possibly other scene entities</p>
</li>
</ul>
</li>
<li><p>For postprocessing, see <a href="https://threejs.org/docs/index.html#manual/en/introduction/How-to-use-post-processing">the docs</a> -- but be careful, as many screen-space post-processing effects do not work well for VR/XR. </p>
</li>
<li><p>Also: animation, raycasting, physics, positional audio, and many more.</p>
</li>
</ul>
<h2 id="starter-code">Starter code</h2>
<p>Three.js code is written in Javascript, embedded within a normal HTML5 page. </p>
<p>For online code sketching, I recommend signing up for an account on <a href="stackblitz.com">stackblitz.com</a>. </p>
<ul>
<li>You can build HTML5 projects entirely in the cloud</li>
<li>It will reload the preview live as you edit</li>
<li>Your project lives on a URL, accessibe anywhere</li>
<li>You can link it to a Github repo, so every &quot;save&quot; becomes a git &quot;commit&quot;, and the entire history of your project is available. </li>
</ul>
<p>Here&#39;s the initial HTML boilerplate. It&#39;s mostly standard HTML boilerplate, with a little CSS to help the canvas fill the page, and a Javascript <code>&lt;script&gt;</code> element with an <code>import</code> to pull in the Three.js library:</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"> 
<span class="hljs-comment">/* remove extra spacing around elements so we can fill the available page */</span>
* { <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; } 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// import the Three.js module:</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> THREE <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://unpkg.com/three@0.126.0/build/three.module.js&quot;</span>;

<span class="hljs-comment">// Our Javascript will go here.</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Everything from now on will be Javascript code inside that <code>&lt;script&gt;</code> element.</p>
<p>To render anything, we need a renderer. We also need an HTML <code>&lt;canvas&gt;</code> to render to; which the renderer can create for us. Here we configure the renderer to use better-than-default quality:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// create a renderer with better than default quality:</span>
<span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer({ <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span> });
renderer.setPixelRatio(<span class="hljs-built_in">window</span>.devicePixelRatio);
<span class="hljs-comment">// make it fill the page</span>
renderer.setSize(<span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight);
<span class="hljs-comment">// create and add the &lt;canvas&gt;</span>
<span class="hljs-built_in">document</span>.body.appendChild(renderer.domElement); 
</code></pre>
<p>The renderer also needs a definition of a <code>camera</code> to define the optics used, and also the viewpoint and direction. Here we use a perspective-based camera (this is always used for VR/XR).</p>
<p>The renderer also needs a <code>scene</code> to know what it should draw. This scene will contain all the objects in the world.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// create a perspective camera</span>
<span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera( 
    <span class="hljs-number">75</span>,  <span class="hljs-comment">// this camera has a 75 degree field of view in the vertical axis</span>
    <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-built_in">window</span>.innerHeight, <span class="hljs-comment">// the aspect ratio matches the size of the window</span>
    <span class="hljs-number">0.05</span>, <span class="hljs-comment">// anything less than 5cm from the eye will not be drawn</span>
    <span class="hljs-number">100</span>  <span class="hljs-comment">// anything more than 100m from the eye will not be drawn</span>
);
<span class="hljs-comment">// position the camera 2m in the Z axis and 1.5m in the Y axis</span>
<span class="hljs-comment">// the Y axis points up from the ground</span>
<span class="hljs-comment">// the Z axis point out of the screen toward you</span>
camera.position.y = <span class="hljs-number">1.5</span>;
camera.position.z = <span class="hljs-number">2</span>;

<span class="hljs-comment">// create the root of a scene graph</span>
<span class="hljs-keyword">const</span> scene = <span class="hljs-keyword">new</span> THREE.Scene();
</code></pre>
<p>To actually create an object we can see, we need to know both its <code>Geometry</code> (it&#39;s shape), as well as its <code>Material</code> (how its surfaces respond to light). Together, the geometry and material are combined as a <code>Mesh</code>, which is also an <code>Object3D</code>. </p>
<p>Here we make a very simple cube, with a standard grey material, add it to the scene and position it 1.5m above ground:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> THREE.BoxGeometry();
<span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> THREE.MeshStandardMaterial();
<span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> THREE.Mesh( geometry, material );
<span class="hljs-comment">// position the cube, and add it to the scene:</span>
cube.position.y = <span class="hljs-number">1.5</span>;
scene.add( cube );
</code></pre>
<p>But, since materials respond to light, we also need a light source! A light is also an <code>Object3D</code>, and needs to be added to the scene. Here we use the generic <code>HemisphereLight</code>: </p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> THREE.HemisphereLight(<span class="hljs-number">0xfff0f0</span>, <span class="hljs-number">0x606066</span>);
scene.add(light);
</code></pre>
<p>Finally, we can add our animation loop -- this is a function that is called on every frame. Here we can update the scene for animation, and finally use the <code>renderer</code>, <code>camera</code> and <code>scene</code> to draw the world to the <code>&lt;canvas&gt;</code>. </p>
<p>Here we added a little code to rotate the cube, so we can see that animation is working:</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// update the scene:</span>
  cube.rotation.x += <span class="hljs-number">0.01</span>;
  cube.rotation.y += <span class="hljs-number">0.01</span>;

  <span class="hljs-comment">// draw the scene:</span>
  renderer.render( scene, camera );
};
<span class="hljs-comment">// start!</span>
renderer.setAnimationLoop(animate);
</code></pre>
<p>All together:</p>
<div id="web-platform-a9gien">web-platform-a9gien</div>
<script>
StackBlitzSDK.embedProjectId('web-platform-a9gien','web-platform-a9gien',{ openFile: 'index.html', theme: 'light', width: "100%", height: "50%", hideExplorer: true, hideNavigation: true, forceEmbedLayout: true, clickToLoad: true, view: "editor" });
</script>

<p>If you want the canvas to resize when the page resizes, you can add this:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// do this now and whenever the window is resized()</span>
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ensure the renderer fills the page, and the camera aspect ratio matches:</span>
  renderer.setSize(<span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight);
  camera.aspect = <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-built_in">window</span>.innerHeight;
  camera.updateProjectionMatrix();
}, <span class="hljs-literal">false</span>);
</code></pre>
<p>If you want to know how well the page is performing, you can add the Stats module:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// load in the module:</span>
<span class="hljs-keyword">import</span> Stats <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://unpkg.com/three@0.126.0/examples/jsm/libs/stats.module&quot;</span>;

<span class="hljs-comment">// add a stats view to the page to monitor performance:</span>
<span class="hljs-keyword">const</span> stats = <span class="hljs-keyword">new</span> Stats();
<span class="hljs-built_in">document</span>.body.appendChild(stats.dom);

<span class="hljs-comment">// wrap everything in the animate function with stats.begin() and stats.end():</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// monitor our FPS:</span>
  stats.begin();

  <span class="hljs-comment">//... everything as it was before ...</span>
  
  <span class="hljs-comment">// monitor our FPS:</span>
  stats.end();
};
</code></pre>
<h2 id="webxr-starter-code">WebXR starter code</h2>
<p>For a WebXR scene, we need to add a few more lines of code:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// load in the VRButton module for the &quot;Enter VR&quot; button</span>
<span class="hljs-keyword">import</span> { VRButton } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;https://cdn.skypack.dev/three@0.126.0/examples/jsm/webxr/VRButton.js&#x27;</span>;

<span class="hljs-comment">// enable XR option in the renderer</span>
renderer.xr.enabled = <span class="hljs-literal">true</span>;
</code></pre>
<div id="web-platform-filbdd">web-platform-filbdd</div>
<script>
StackBlitzSDK.embedProjectId('web-platform-filbdd','web-platform-filbdd',{ openFile: 'index.html', theme: 'light', width: "100%", height: "50%", hideExplorer: true, hideNavigation: true, forceEmbedLayout: true, clickToLoad: true, view: "editor" });
</script>


<h2 id="notes-on-stackblitz">Notes on Stackblitz</h2>
<p>If you want to write your Stackblitz code as a module, I found that I had to load Three.js this way:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> THREE = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;https://cdn.skypack.dev/three@0.126.0&#x27;</span>);
<span class="hljs-keyword">const</span> { OrbitControls } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(
  <span class="hljs-string">&#x27;https://cdn.skypack.dev/three@0.126.0/examples/jsm/controls/OrbitControls.js&#x27;</span>
);
<span class="hljs-comment">// etc.</span>
</code></pre>
<p>If you want to load static resources such as models, image textures, etc., they will need to be on a public server URL with appropriate access sharing, as Stackblitz itself does not currently have good support for static files. </p>
<p>I can recommend using a <a href="https://pages.github.com">Github pages</a> account.  Any Github repository can be a static file server by adding a branch called <code>gh-pages</code>. Note that there is a file size limit of around 25mb -- but you should avoid even files as large as this anyway, to prevent slow downloads of the site! </p>
<h2 id="timing">Timing</h2>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> clock = <span class="hljs-keyword">new</span> THREE.Clock();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// get current timing:</span>
  <span class="hljs-keyword">const</span> dt = clock.getDelta();
  <span class="hljs-keyword">const</span> t = clock.getElapsedTime();

  <span class="hljs-comment">// ...</span>
};
</code></pre>
<h2 id="navigation">Navigation</h2>
<p>For an object-centric viewpoint, look at <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls">Orbit controls</a>, but see also <a href="https://threejs.org/docs/?q=controls#examples/en/controls/TrackballControls">Track ball controls</a></p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { OrbitControls } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js&#x27;</span>;

<span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> OrbitControls(camera, renderer.domElement);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//...</span>
  controls.update(dt);
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>For free movement in 3D space, look at <a href="https://threejs.org/docs/?q=controls#examples/en/controls/FlyControls">Fly controls</a>, but see also <a href="https://threejs.org/docs/?q=controls#examples/en/controls/FirstPersonControls">First person controls</a></p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { FlyControls } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;https://unpkg.com/three@0.126.0/examples/jsm/controls/FlyControls.js&#x27;</span>;

<span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> FlyControls(camera, renderer.domElement);
controls.movementSpeed = <span class="hljs-number">1</span>;
controls.rollSpeed = <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">3</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//...</span>
  controls.update(dt);
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>For a WASD style interface, start from <a href="https://threejs.org/docs/?q=controls#examples/en/controls/PointerLockControls">Pointer lock controls</a></p>
<p><a href="https://threejs.org/examples/#misc_controls_pointerlock">See also example code</a></p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { PointerLockControls } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;https://unpkg.com/three@0.126.0/examples/jsm/controls/PointerLockControls.js&#x27;</span>;

<span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> PointerLockControls( camera, <span class="hljs-built_in">document</span>.body );
scene.add(controls.getObject());

<span class="hljs-comment">// Pointer lock requires a user action to start, e.g. click on canvas to start pointerlock:</span>
renderer.domElement.addEventListener( <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    controls.lock();
});
<span class="hljs-comment">// get callbacks when this happens:</span>
<span class="hljs-comment">// controls.addEventListener( &#x27;lock&#x27;, function () { /* e.g. hide &quot;click to look&quot; instructions */ })</span>
<span class="hljs-comment">// controls.addEventListener( &#x27;unlock&#x27;, function () {  /* e.g. show &quot;click to look&quot; instructions */  })</span>

<span class="hljs-comment">// for WASD:</span>
<span class="hljs-keyword">const</span> move = {
  <span class="hljs-attr">forward</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">backward</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>, 
  <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">dir</span>: <span class="hljs-keyword">new</span> THREE.Vector3(),
}

<span class="hljs-built_in">document</span>.addEventListener( <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">switch</span> ( event.code ) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowUp&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyW&#x27;</span>:
            move.forward = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowLeft&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyA&#x27;</span>:
            move.left = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowDown&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyS&#x27;</span>:
            move.backward = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowRight&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyD&#x27;</span>:
            move.right = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">break</span>;
    }
});

<span class="hljs-built_in">document</span>.addEventListener( <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">switch</span> ( event.code ) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowUp&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyW&#x27;</span>:
            move.forward = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowLeft&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyA&#x27;</span>:
            move.left = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowDown&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyS&#x27;</span>:
            move.backward = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrowRight&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;KeyD&#x27;</span>:
            move.right = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
    }
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (controls.isLocked === <span class="hljs-literal">true</span>) {
    <span class="hljs-comment">// use move properties and controls.moveRight() / controls.moveForward() to modify camera...</span>
    <span class="hljs-comment">// use controls.getObject().position for navigation limits / collisions etc.</span>
    move.dir.z = move.forward - move.backward;
    move.dir.x = move.right - move.left;
    move.dir.normalize();
    <span class="hljs-keyword">let</span> spd = <span class="hljs-number">3</span> * dt;  <span class="hljs-comment">// or 3/60</span>
    controls.moveRight(move.dir.x * spd);
    controls.moveForward(move.dir.z * spd);
  }
}
</code></pre>
<h2 id="a-quick-gui">A quick GUI</h2>
<p>This is a desktop-only GUI, it won&#39;t appear in VR. </p>
<p><a href="https://github.com/SolalDR/three-dat.gui#readme">See documentation here</a></p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { GUI } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(
  <span class="hljs-string">&#x27;https://unpkg.com/three@0.126.0/examples/jsm/libs/dat.gui.module.js&#x27;</span>
);

<span class="hljs-keyword">const</span> settings = {
  <span class="hljs-comment">// your parameters here, e.g.:</span>
  <span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span>,
}

<span class="hljs-keyword">const</span> gui = <span class="hljs-keyword">new</span> GUI();
gui.add(settings, <span class="hljs-string">&#x27;enable&#x27;</span>).onChange(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
  <span class="hljs-comment">// do something with `value` here</span>
});
</code></pre>
<!-- 
## Point clouds

`new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial())`

https://threejs.org/docs/?q=point#api/en/objects/Points
- Optionally, set index attribute for indexed buffer geometry
- supports raycast intersections
- has some kind of morph target capability
- draw subranges: `geometry.setDrawRange(start, count)` and `attributes.setUsage( THREE.DynamicDrawUsage ) )`
- optionally, add groups. Each group can be a different drawRange, and have a different material

https://threejs.org/docs/?q=point#api/en/materials/PointsMaterial
- colour / map / alphaMap for setting colour/texture (color all points at once, or use vertexColors: true for per-vertex `color` attribute)
- size / sizeAtten (bool) for size-by-distance (all points at once)
- may also want to set blending: THREE.AdditiveBlending, depthTest: false, transparent: true
- For anything fancier, will need a custom RawShaderMaterial 

Examples
- https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_raycasting_points.html -- raycasting points
- https://github.com/mrdoob/three.js/blob/master/examples/webgl_points_dynamic.html -- cloud from OBJ, and also modifying geometry
- https://github.com/mrdoob/three.js/blob/master/examples/webgl_buffergeometry_points_interleaved.html -- using interleaved arraybuffer to store e.g. 32-bit position and 8-bit colour in a single 128-bit struct-per-particle 
- https://github.com/mrdoob/three.js/blob/master/examples/webgl_buffergeometry_drawrange.html -- varying the drawRange of the buffer

To generate particle sprite textures, can load from images of course, but can also generate via HTML5 Canvas and new THREE.CanvasTexture(), or from raw data using new THREE.DataTexture(). 

Possibly also consider using instancedBufferGeometry with a quad? E.g. https://tympanus.net/codrops/2019/01/17/interactive-particles-with-three-js/

Codepen demo: https://codepen.io/grrrwaaa/pen/gOWyPNY 


## Live Coding Three.js? In VR?

- Basic live code editor written by Three.js author https://mrdoob.com/projects/htmleditor/
  - Source: https://github.com/mrdoob/htmleditor
  - Essentially a document-level reloader: entire HTML doc is edited in text overlay and reloaded into iframe below it on each (successful) edit

- A more visual editor also by Three.js https://threejs.org/editor/
  - Source: https://github.com/mrdoob/three.js/tree/master/editor
  - More of a scene-graph, unity-like interface. 
  - Top of tree has Camera, Scene (Renderer is in a settings page)
  - Each node has inspector for object, material, geometry, and possible script components. ```this``` used to access the object (e.g. the Scene in the Scene's script),
  - an ```update(event)``` routine allows per-frame actions, ```pointermove(event)```, probably other callbacks. 
  - Scene script acts as the main game script in most of the exmaples.
  - ```scene.getObjectByName( 'Brick' )``` to find other objects.
  - Materials can be standard three.js materials or custom shaders (with GLSL code editors for interface / vertex shader / fragment shader)

- A similar approach, more fleshed out, by Mozilla Hubs https://hubs.mozilla.com/spoke
  - Includes asset import from google poly etc.

- Built on React https://github.com/ekatzenstein/three.js-live
- Built on Coffee etc. https://livecodelab.net
- Built on Clojure script https://github.com/cassiel/threejs-figwheel-main 



### Memory & cleanup

- See these docs: https://threejs.org/docs/index.html#manual/en/introduction/How-to-dispose-of-objects

### no text input in VR

From within VR, a code-oriented interface is almost unworkable. Some kind of visual interface would make more sense: editing in terms of structural components, intentions, relations, flows etc. rather than JS directly. In concept this is certainly feasible: A-Frame does the very same thing, using a DOM interface to generate Three.js code. 

> Perhaps in a form that can still be code-edited from desktop experiences. That means a projectional editor. (https://www.martinfowler.com/bliki/ProjectionalEditing.html, https://en.wikipedia.org/wiki/Structure_editor). 

### What level of abstraction?

- Reload entire sub-page as an iframe (https://mrdoob.com/projects/htmleditor/)? 
- Or modify scene graph / replace scene/renderer and replace animate() ?
- Something somewhere in between, in a more p5 style. Minimal example here: https://codepen.io/grrrwaaa/pen/yLMaYeR

iframe option has advantage of no leaky state (instead we have to provide serialization/deserialization to preserve state if & as desired). Any preference from VR perspective?

## Setting up a project



-->
<footer>DATT4520/DIGM5520 2021-22</footer>
</body>
<script src="js/connect.js"></script>
</html>